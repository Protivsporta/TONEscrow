/// <reference types="node" />
import BN from "bn.js";
import { Address, Cell, Contract, ContractSource, TonClient } from "..";
export declare class ConfigContract implements Contract {
    readonly address: Address;
    readonly source: ContractSource;
    private readonly client;
    constructor(client: TonClient);
    getSeqNo(): Promise<number>;
    getPublicKey(): Promise<BN>;
    getConfigsRaw(): Promise<Map<string, import("..").Slice>>;
    getConfigs(): Promise<{
        configAddress: Address;
        electorAddress: Address;
        minterAddress: Address | null;
        feeCollectorAddress: Address | null;
        dnsRootAddress: Address | null;
        globalVersion: {
            version: number;
            capabilities: BN;
        };
        workchains: Map<string, {
            enabledSince: number;
            actialMinSplit: number;
            min_split: number;
            max_split: number;
            basic: boolean;
            active: boolean;
            accept_msgs: boolean;
            flags: number;
            zerostateRootHash: Buffer;
            zerostateFileHash: Buffer;
            version: number;
            format: {
                vmVersion: number;
                vmMode: BN;
            };
        }>;
        voting: {
            normalParams: {
                minTotalRounds: number;
                maxTotalRounds: number;
                minWins: number;
                maxLoses: number;
                minStoreSec: number;
                maxStoreSec: number;
                bitPrice: number;
                cellPrice: number;
            };
            criticalParams: {
                minTotalRounds: number;
                maxTotalRounds: number;
                minWins: number;
                maxLoses: number;
                minStoreSec: number;
                maxStoreSec: number;
                bitPrice: number;
                cellPrice: number;
            };
        };
        validators: {
            minStake: BN;
            maxStake: BN;
            minTotalStake: BN;
            maxStakeFactor: number;
            maxValidators: number;
            maxMainValidators: number;
            minValidators: number;
            validatorsElectedFor: number;
            electorsStartBefore: number;
            electorsEndBefore: number;
            stakeHeldFor: number;
        };
        storagePrices: import("./configs/configParsing").StoragePrices[];
        gasPrices: {
            masterchain: {
                flatLimit: BN;
                flatGasPrice: BN;
                other: {
                    gasPrice: BN;
                    gasLimit: BN;
                    specialGasLimit: BN;
                    gasCredit: BN;
                    blockGasLimit: BN;
                    freezeDueLimit: BN;
                    deleteDueLimit: BN;
                } | {
                    gasPrice: BN;
                    gasLimit: BN;
                    gasCredit: BN;
                    blockGasLimit: BN;
                    freezeDueLimit: BN;
                    deleteDueLimit: BN;
                    specialGasLimit?: undefined;
                };
            };
            workchain: {
                flatLimit: BN;
                flatGasPrice: BN;
                other: {
                    gasPrice: BN;
                    gasLimit: BN;
                    specialGasLimit: BN;
                    gasCredit: BN;
                    blockGasLimit: BN;
                    freezeDueLimit: BN;
                    deleteDueLimit: BN;
                } | {
                    gasPrice: BN;
                    gasLimit: BN;
                    gasCredit: BN;
                    blockGasLimit: BN;
                    freezeDueLimit: BN;
                    deleteDueLimit: BN;
                    specialGasLimit?: undefined;
                };
            };
        };
        msgPrices: {
            masterchain: {
                lumpPrice: BN;
                bitPrice: BN;
                cellPrice: BN;
                ihrPriceFactor: BN;
                firstFrac: BN;
                nextFrac: BN;
            };
            workchain: {
                lumpPrice: BN;
                bitPrice: BN;
                cellPrice: BN;
                ihrPriceFactor: BN;
                firstFrac: BN;
                nextFrac: BN;
            };
        };
        validatorSets: {
            prevValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
            prevTempValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
            currentValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
            currentTempValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
            nextValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
            nextTempValidators: {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: null;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }>;
            } | {
                timeSince: number;
                timeUntil: number;
                total: number;
                main: number;
                totalWeight: BN;
                list: Map<string, {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: null;
                } | {
                    publicKey: Buffer;
                    weight: BN;
                    adnlAddress: Buffer;
                }> | null;
            } | null | undefined;
        };
        validatorsPunish: {
            defaultFlatFine: BN;
            defaultProportionaFine: BN;
            severityFlatMult: number;
            severityProportionalMult: number;
            unfunishableInterval: number;
            longInterval: number;
            longFlatMult: number;
            longProportionalMult: number;
            mediumInterval: number;
            mediumFlatMult: number;
            mediumProportionalMult: number;
        } | null;
        bridges: {
            ethereum: {
                bridgeAddress: Buffer;
                oracleMultisigAddress: Buffer;
                oracles: Map<string, Buffer> | null;
                externalChainAddress: Buffer;
            } | null;
            binance: {
                bridgeAddress: Buffer;
                oracleMultisigAddress: Buffer;
                oracles: Map<string, Buffer> | null;
                externalChainAddress: Buffer;
            } | null;
            polygon: {
                bridgeAddress: Buffer;
                oracleMultisigAddress: Buffer;
                oracles: Map<string, Buffer> | null;
                externalChainAddress: Buffer;
            } | null;
        };
        catchain: {
            masterCatchainLifetime: number;
            shardCatchainLifetime: number;
            shardValidatorsLifetime: number;
            shardValidatorsCount: number;
            flags?: undefined;
            suffleMasterValidators?: undefined;
        } | {
            flags: number;
            suffleMasterValidators: boolean;
            masterCatchainLifetime: number;
            shardCatchainLifetime: number;
            shardValidatorsLifetime: number;
            shardValidatorsCount: number;
        };
        consensus: {
            roundCandidates: number;
            nextCandidateDelay: number;
            consensusTimeout: number;
            fastAttempts: number;
            attemptDuration: number;
            catchainMaxDeps: number;
            maxBlockBytes: number;
            maxColaltedBytes: number;
            flags?: undefined;
            newCatchainIds?: undefined;
            protoVersion?: undefined;
        } | {
            flags: number;
            newCatchainIds: boolean;
            roundCandidates: number;
            nextCandidateDelay: number;
            consensusTimeout: number;
            fastAttempts: number;
            attemptDuration: number;
            catchainMaxDeps: number;
            maxBlockBytes: number;
            maxColaltedBytes: number;
            protoVersion?: undefined;
        } | {
            flags: number;
            newCatchainIds: boolean;
            roundCandidates: number;
            nextCandidateDelay: number;
            consensusTimeout: number;
            fastAttempts: number;
            attemptDuration: number;
            catchainMaxDeps: number;
            maxBlockBytes: number;
            maxColaltedBytes: number;
            protoVersion: number;
        };
    }>;
    createProposal(args: {
        queryId: BN;
        expiresAt: number;
        critical: boolean;
        paramId: number;
        paramValue: Cell | null;
        ifHashEqual: Cell | null;
    }): Promise<Cell>;
}
