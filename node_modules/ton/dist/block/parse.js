"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;
const __1 = require("..");
const parseDict_1 = require("../boc/dict/parseDict");
function parseAccountStatus(slice) {
    const status = slice.readUintNumber(2);
    if (status === 0x00) {
        return 'uninitialized';
    }
    if (status === 0x01) {
        return 'frozen';
    }
    if (status === 0x02) {
        return 'active';
    }
    if (status === 0x03) {
        return 'non-existing';
    }
    throw Error('Invalid data');
}
exports.parseAccountStatus = parseAccountStatus;
function parseCurrencyCollection(slice) {
    const coins = slice.readCoins();
    // Read extra currencies
    let extraCurrencies = null;
    if (slice.readBit()) {
        let dc = slice.readCell();
        if (!dc.isExotic) {
            let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, (s) => s.readVarUIntNumber(5));
            extraCurrencies = new Map();
            for (let e of pd) {
                extraCurrencies.set(parseInt(e[0], 10), e[1]);
            }
        }
    }
    return { extraCurrencies, coins };
}
exports.parseCurrencyCollection = parseCurrencyCollection;
function parseCommonMsgInfo(slice) {
    if (!slice.readBit()) {
        // Internal
        let ihrDisabled = slice.readBit();
        let bounce = slice.readBit();
        let bounced = slice.readBit();
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let value = parseCurrencyCollection(slice);
        let ihrFee = slice.readCoins();
        let fwdFee = slice.readCoins();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
            type: 'internal',
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            fwdFee,
            createdLt,
            createdAt
        };
    }
    else if (slice.readBit()) {
        // Outgoing external
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
            type: 'external-out',
            src,
            dest,
            createdLt,
            createdAt
        };
    }
    else {
        // Incoming external
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let importFee = slice.readCoins();
        return {
            type: 'external-in',
            src,
            dest,
            importFee
        };
    }
}
exports.parseCommonMsgInfo = parseCommonMsgInfo;
function parseRawTickTock(slice) {
    return {
        tick: slice.readBit(),
        tock: slice.readBit()
    };
}
exports.parseRawTickTock = parseRawTickTock;
function parseStateInit(slice) {
    let raw = slice.toCell();
    let splitDepth = null;
    if (slice.readBit()) {
        splitDepth = slice.readUintNumber(5);
    }
    const special = slice.readBit() ? parseRawTickTock(slice) : null;
    const hasCode = slice.readBit();
    const code = hasCode ? slice.readCell() : null;
    const hasData = slice.readBit();
    const data = hasData ? slice.readCell() : null;
    if (slice.readBit()) {
        slice.readCell(); // Skip libraries for now
    }
    return { splitDepth, data, code, special, raw };
}
exports.parseStateInit = parseStateInit;
function parseMessage(slice) {
    const raw = slice.toCell();
    const info = parseCommonMsgInfo(slice);
    const hasInit = slice.readBit();
    let init = null;
    if (hasInit) {
        if (!slice.readBit()) {
            init = parseStateInit(slice);
        }
        else {
            init = parseStateInit(slice.readRef());
        }
    }
    const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
    return {
        info,
        init,
        body,
        raw
    };
}
exports.parseMessage = parseMessage;
function parseHashUpdate(slice) {
    if (slice.readUintNumber(8) !== 0x72) {
        throw Error('Invalid data');
    }
    const oldHash = slice.readBuffer(32);
    const newHash = slice.readBuffer(32);
    return { oldHash, newHash };
}
exports.parseHashUpdate = parseHashUpdate;
function parseAccountChange(slice) {
    if (!slice.readBit()) {
        return 'unchanged';
    }
    if (slice.readBit()) {
        return 'frozen';
    }
    else {
        return 'deleted';
    }
}
exports.parseAccountChange = parseAccountChange;
function parseStorageUsedShort(slice) {
    return {
        cells: slice.readVarUIntNumber(3),
        bits: slice.readVarUIntNumber(3)
    };
}
exports.parseStorageUsedShort = parseStorageUsedShort;
function parseStoragePhase(slice) {
    const storageFeesCollected = slice.readCoins();
    let storageFeesDue = null;
    if (slice.readBit()) {
        storageFeesDue = slice.readCoins();
    }
    const statusChange = parseAccountChange(slice);
    return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
    };
}
exports.parseStoragePhase = parseStoragePhase;
function parseCreditPhase(slice) {
    let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;
    const credit = parseCurrencyCollection(slice);
    return {
        dueFeesColelcted,
        credit
    };
}
exports.parseCreditPhase = parseCreditPhase;
function parseComputePhase(slice) {
    if (!slice.readBit()) {
        const skipReason = slice.readUintNumber(2);
        if (skipReason === 0x00) {
            return {
                type: 'skipped',
                reason: 'no-state'
            };
        }
        if (skipReason === 0x01) {
            return {
                type: 'skipped',
                reason: 'bad-state'
            };
        }
        if (skipReason === 0x02) {
            return {
                type: 'skipped',
                reason: 'no-gas'
            };
        }
    }
    const success = slice.readBit();
    const messageStateUsed = slice.readBit();
    const accountActivated = slice.readBit();
    let gasFees = slice.readCoins();
    const vmState = slice.readRef();
    let gasUsed = vmState.readVarUInt(3);
    let gasLimit = vmState.readVarUInt(3);
    let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;
    let mode = vmState.readUintNumber(8);
    let exitCode = vmState.readUintNumber(32);
    let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int
    let vmSteps = vmState.readUintNumber(32);
    let vmInitStateHash = vmState.readBuffer(32);
    let vmFinalStateHash = vmState.readBuffer(32);
    return {
        type: 'computed',
        success,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
    };
}
exports.parseComputePhase = parseComputePhase;
function parseActionPhase(slice) {
    const success = slice.readBit();
    const valid = slice.readBit();
    const noFunds = slice.readBit();
    const statusChange = parseAccountChange(slice);
    const totalFwdFees = slice.readBit() ? slice.readCoins() : null;
    const totalActionFees = slice.readBit() ? slice.readCoins() : null;
    const resultCode = slice.readUintNumber(32); // TODO: Change to int32
    const resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32
    const totalActions = slice.readUintNumber(16);
    const specialActions = slice.readUintNumber(16);
    const skippedActions = slice.readUintNumber(16);
    const messagesCreated = slice.readUintNumber(16);
    const actionListHash = slice.readBuffer(32);
    const totalMessageSizes = parseStorageUsedShort(slice);
    return {
        success,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specialActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSizes
    };
}
exports.parseActionPhase = parseActionPhase;
function parseBouncePhase(slice) {
    // Is OK
    if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const msgFees = slice.readCoins();
        const fwdFees = slice.readCoins();
        return {
            type: 'ok',
            msgSize,
            msgFees,
            fwdFees
        };
    }
    // No funds
    if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const fwdFees = slice.readCoins();
        return {
            type: 'no-funds',
            msgSize,
            fwdFees
        };
    }
    return {
        type: 'negative-funds'
    };
}
exports.parseBouncePhase = parseBouncePhase;
function parseTransactionDescription(slice) {
    const type = slice.readUintNumber(4);
    if (type === 0x00) {
        const creditFirst = slice.readBit();
        let storagePhase = null;
        let creditPhase = null;
        if (slice.readBit()) {
            storagePhase = parseStoragePhase(slice);
        }
        if (slice.readBit()) {
            creditPhase = parseCreditPhase(slice);
        }
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
        }
        let aborted = slice.readBit();
        let bouncePhase = null;
        if (slice.readBit()) {
            bouncePhase = parseBouncePhase(slice);
        }
        const destroyed = slice.readBit();
        return {
            type: 'generic',
            creditFirst,
            storagePhase,
            creditPhase,
            computePhase,
            actionPhase,
            bouncePhase,
            aborted,
            destroyed
        };
    }
    if (type === 0x01) {
        let storagePhase = parseStoragePhase(slice);
        return {
            type: 'storage',
            storagePhase
        };
    }
    if (type === 0x2 || type === 0x03) {
        const isTock = type === 0x03;
        let storagePhase = parseStoragePhase(slice);
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
        }
        const aborted = slice.readBit();
        const destroyed = slice.readBit();
        return {
            type: 'tick-tock',
            isTock,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
        };
    }
    throw Error('Unsupported transaction type');
}
exports.parseTransactionDescription = parseTransactionDescription;
function parseTransaction(workchain, slice) {
    if (slice.readUintNumber(4) !== 0x07) {
        throw Error('Invalid data');
    }
    // Read address
    const addressHash = slice.readBuffer(32);
    const address = new __1.Address(workchain, addressHash);
    // Read lt
    const lt = slice.readUint(64);
    // Read prevTrans
    const prevTransHash = slice.readBuffer(32);
    const prevTransLt = slice.readUint(64);
    // Read time
    const time = slice.readUintNumber(32);
    // Output messages
    const outMessagesCount = slice.readUintNumber(15);
    // Status
    const oldStatus = parseAccountStatus(slice);
    const newStatus = parseAccountStatus(slice);
    // Messages ref
    const messages = slice.readRef();
    let hasInMessage = messages.readBit();
    let hasOutMessages = messages.readBit();
    let inMessage = null;
    if (hasInMessage) {
        inMessage = parseMessage(messages.readRef());
    }
    let outMessages = [];
    if (hasOutMessages) {
        let dict = messages.readDict(15, (slice) => parseMessage(slice.readRef()));
        for (let msg of Array.from(dict.values())) {
            outMessages.push(msg);
        }
    }
    // Currency collections
    let fees = parseCurrencyCollection(slice);
    // Hash update
    let update = parseHashUpdate(slice.readRef());
    // Description
    let description = parseTransactionDescription(slice.readRef());
    return {
        address,
        lt,
        time,
        outMessagesCount,
        oldStatus,
        newStatus,
        fees,
        update,
        description,
        inMessage,
        outMessages,
        prevTransaction: {
            hash: prevTransHash,
            lt: prevTransLt
        }
    };
}
exports.parseTransaction = parseTransaction;
function parseStorageUsed(cs) {
    return {
        cells: cs.readVarUIntNumber(3),
        bits: cs.readVarUIntNumber(3),
        publicCells: cs.readVarUIntNumber(3),
    };
}
exports.parseStorageUsed = parseStorageUsed;
function parseStorageInfo(cs) {
    return {
        used: parseStorageUsed(cs),
        lastPaid: cs.readUintNumber(32),
        duePayment: cs.readBit() ? cs.readCoins() : null
    };
}
exports.parseStorageInfo = parseStorageInfo;
function parseAccountState(cs) {
    if (cs.readBit()) {
        return { type: 'active', state: parseStateInit(cs) };
    }
    else if (cs.readBit()) {
        return { type: 'frozen', stateHash: cs.readBuffer(32) };
    }
    else {
        return { type: 'uninit' };
    }
}
exports.parseAccountState = parseAccountState;
function parseAccountStorage(cs) {
    return { lastTransLt: cs.readUint(64), balance: parseCurrencyCollection(cs), state: parseAccountState(cs) };
}
exports.parseAccountStorage = parseAccountStorage;
function parseAccount(cs) {
    if (cs.readBit()) {
        return {
            address: cs.readAddress(),
            storageStat: parseStorageInfo(cs),
            storage: parseAccountStorage(cs)
        };
    }
    else {
        return null;
    }
}
exports.parseAccount = parseAccount;
function parseShardIdent(cs) {
    if (cs.readUintNumber(2) !== 0) {
        throw Error('Invalid data');
    }
    let shardPrefixBits = cs.readUintNumber(6);
    let workchainId = cs.readIntNumber(32);
    let shardPrefix = cs.readUint(64);
    return {
        shardPrefixBits,
        workchainId,
        shardPrefix
    };
}
exports.parseShardIdent = parseShardIdent;
function parseShardAccount(cs) {
    let accountCell = cs.readCell();
    let address = null;
    if (!accountCell.isExotic) {
        address = accountCell.beginParse().readAddress();
    }
    return {
        address,
        lastTransHash: cs.readBuffer(32),
        lastTransLt: cs.readUint(64)
    };
}
exports.parseShardAccount = parseShardAccount;
function parseDepthBalanceInfo(cs) {
    return {
        splitDepth: cs.readUintNumber(5),
        balance: parseCurrencyCollection(cs)
    };
}
exports.parseDepthBalanceInfo = parseDepthBalanceInfo;
function parseShardAccounts(cs) {
    if (!cs.readBit()) {
        return new Map();
    }
    return (0, parseDict_1.parseDict)(cs.readRef(), 256, (cs2) => {
        let depthBalanceInfo = parseDepthBalanceInfo(cs2);
        let shardAccount = parseShardAccount(cs2);
        return {
            depthBalanceInfo,
            shardAccount
        };
    });
}
exports.parseShardAccounts = parseShardAccounts;
function parseMasterchainStateExtra(cs) {
    // Check magic
    if (cs.readUintNumber(16) !== 0xcc26) {
        throw Error('Invalid data');
    }
    // Skip shard_hashes
    if (cs.readBit()) {
        cs.readCell();
    }
    // Read config
    let configAddress = new __1.Address(-1, cs.readBuffer(32));
    let config = cs.readCell();
    // Rad global balance
    const globalBalance = parseCurrencyCollection(cs);
    return {
        config,
        configAddress,
        globalBalance
    };
}
exports.parseMasterchainStateExtra = parseMasterchainStateExtra;
function parseShardStateUnsplit(cs) {
    if (cs.readUintNumber(32) !== 0x9023afe2) {
        throw Error('Invalid data');
    }
    let globalId = cs.readIntNumber(32);
    let shardId = parseShardIdent(cs);
    let seqno = cs.readUintNumber(32);
    let vertSeqNo = cs.readUintNumber(32);
    let genUtime = cs.readUintNumber(32);
    let genLt = cs.readUint(64);
    let minRefSeqno = cs.readUintNumber(32);
    // Skip OutMsgQueueInfo: usually exotic
    cs.readCell();
    let beforeSplit = cs.readBit();
    // Parse accounts
    let accounts;
    let accountsCell = cs.readCell();
    if (accountsCell.isExotic) {
        accounts = new Map();
    }
    else {
        accounts = parseShardAccounts(accountsCell.beginParse());
    }
    // Skip (not used by apps)
    cs.readCell();
    // Parse extras
    let mcStateExtra = cs.readBit();
    let extras = null;
    if (mcStateExtra) {
        let cell = cs.readCell();
        if (!cell.isExotic) {
            extras = parseMasterchainStateExtra(cell.beginParse());
        }
    }
    ;
    return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefSeqno,
        beforeSplit,
        accounts,
        extras
    };
}
exports.parseShardStateUnsplit = parseShardStateUnsplit;
