/// <reference types="node" />
import BN from "bn.js";
import { Address, Cell, Slice } from "..";
export declare type RawAccountStatus = 'uninitialized' | 'frozen' | 'active' | 'non-existing';
export declare function parseAccountStatus(slice: Slice): RawAccountStatus;
export declare type RawCurrencyCollection = {
    extraCurrencies: Map<number, number> | null;
    coins: BN;
};
export declare function parseCurrencyCollection(slice: Slice): RawCurrencyCollection;
export declare type RawCommonMessageInfo = {
    type: 'internal';
    ihrDisabled: boolean;
    bounce: boolean;
    bounced: boolean;
    src: Address | null;
    dest: Address | null;
    value: RawCurrencyCollection;
    ihrFee: BN;
    fwdFee: BN;
    createdLt: BN;
    createdAt: number;
} | {
    type: 'external-out';
    src: Address | null;
    dest: Address | null;
    createdLt: BN;
    createdAt: number;
} | {
    type: 'external-in';
    src: Address | null;
    dest: Address | null;
    importFee: BN;
};
export declare function parseCommonMsgInfo(slice: Slice): RawCommonMessageInfo;
export declare type RawTickTock = {
    tick: boolean;
    tock: boolean;
};
export declare function parseRawTickTock(slice: Slice): RawTickTock;
export declare type RawStateInit = {
    splitDepth: number | null;
    code: Cell | null;
    data: Cell | null;
    special: RawTickTock | null;
    raw: Cell;
};
export declare function parseStateInit(slice: Slice): RawStateInit;
export declare type RawMessage = {
    raw: Cell;
    info: RawCommonMessageInfo;
    init: RawStateInit | null;
    body: Cell;
};
export declare function parseMessage(slice: Slice): RawMessage;
export declare type RawHashUpdate = {
    oldHash: Buffer;
    newHash: Buffer;
};
export declare function parseHashUpdate(slice: Slice): RawHashUpdate;
export declare type RawAccountStatusChange = 'unchanged' | 'frozen' | 'deleted';
export declare function parseAccountChange(slice: Slice): RawAccountStatusChange;
export declare type RawStorageUsedShort = {
    cells: number;
    bits: number;
};
export declare function parseStorageUsedShort(slice: Slice): RawStorageUsedShort;
export declare type RawStoragePhase = {
    storageFeesCollected: BN;
    storageFeesDue: BN | null;
    statusChange: RawAccountStatusChange;
};
export declare function parseStoragePhase(slice: Slice): RawStoragePhase;
export declare type RawCreditPhase = {
    dueFeesColelcted: BN | null;
    credit: RawCurrencyCollection;
};
export declare function parseCreditPhase(slice: Slice): RawCreditPhase;
export declare type RawComputePhase = {
    type: 'skipped';
    reason: 'no-state' | 'bad-state' | 'no-gas';
} | {
    type: 'computed';
    success: boolean;
    messageStateUsed: boolean;
    accountActivated: boolean;
    gasFees: BN;
    gasUsed: BN;
    gasLimit: BN;
    gasCredit: BN | null;
    mode: number;
    exitCode: number;
    exitArg: number | null;
    vmSteps: number;
    vmInitStateHash: Buffer;
    vmFinalStateHash: Buffer;
};
export declare function parseComputePhase(slice: Slice): RawComputePhase;
export declare type RawActionPhase = {
    success: boolean;
    valid: boolean;
    noFunds: boolean;
    statusChange: RawAccountStatusChange;
    totalFwdFees: BN | null;
    totalActionFees: BN | null;
    resultCode: number;
    resultArg: number | null;
    totalActions: number;
    specialActions: number;
    skippedActions: number;
    messagesCreated: number;
    actionListHash: Buffer;
    totalMessageSizes: RawStorageUsedShort;
};
export declare function parseActionPhase(slice: Slice): RawActionPhase;
export declare type RawBouncePhase = {
    type: 'ok';
    msgSize: RawStorageUsedShort;
    msgFees: BN;
    fwdFees: BN;
} | {
    type: 'no-funds';
    msgSize: RawStorageUsedShort;
    fwdFees: BN;
} | {
    type: 'negative-funds';
};
export declare function parseBouncePhase(slice: Slice): RawBouncePhase;
export declare type RawTransactionDescription = {
    type: 'generic';
    creditFirst: boolean;
    storagePhase: RawStoragePhase | null;
    creditPhase: RawCreditPhase | null;
    computePhase: RawComputePhase;
    actionPhase: RawActionPhase | null;
    bouncePhase: RawBouncePhase | null;
    aborted: boolean;
    destroyed: boolean;
} | {
    type: 'storage';
    storagePhase: RawStoragePhase;
} | {
    type: 'tick-tock';
    isTock: boolean;
    storagePhase: RawStoragePhase;
    computePhase: RawComputePhase;
    actionPhase: RawActionPhase | null;
    aborted: boolean;
    destroyed: boolean;
};
export declare function parseTransactionDescription(slice: Slice): RawTransactionDescription;
export declare type RawTransaction = {
    address: Address;
    lt: BN;
    prevTransaction: {
        lt: BN;
        hash: Buffer;
    };
    time: number;
    outMessagesCount: number;
    oldStatus: RawAccountStatus;
    newStatus: RawAccountStatus;
    fees: RawCurrencyCollection;
    update: RawHashUpdate;
    description: RawTransactionDescription;
    inMessage: RawMessage | null;
    outMessages: RawMessage[];
};
export declare function parseTransaction(workchain: number, slice: Slice): RawTransaction;
export declare type RawStorageUsed = {
    cells: number;
    bits: number;
    publicCells: number;
};
export declare function parseStorageUsed(cs: Slice): RawStorageUsed;
export declare type RawStorageInfo = {
    used: RawStorageUsed;
    lastPaid: number;
    duePayment: BN | null;
};
export declare function parseStorageInfo(cs: Slice): RawStorageInfo;
export declare type RawAccountState = {
    type: 'uninit';
} | {
    type: 'active';
    state: RawStateInit;
} | {
    type: 'frozen';
    stateHash: Buffer;
};
export declare function parseAccountState(cs: Slice): RawAccountState;
export declare type RawAccountStorage = {
    lastTransLt: BN;
    balance: RawCurrencyCollection;
    state: RawAccountState;
};
export declare function parseAccountStorage(cs: Slice): RawAccountStorage;
export declare type RawAccount = {
    addr: Address | null;
    storageStat: RawStorageInfo;
    storage: RawAccountStorage;
};
export declare function parseAccount(cs: Slice): {
    address: Address | null;
    storageStat: RawStorageInfo;
    storage: RawAccountStorage;
} | null;
export declare type RawShardIdent = {
    shardPrefixBits: number;
    workchainId: number;
    shardPrefix: BN;
};
export declare function parseShardIdent(cs: Slice): {
    shardPrefixBits: number;
    workchainId: number;
    shardPrefix: BN;
};
export declare type RawShardAccount = {
    address: Address | null;
    lastTransHash: Buffer;
    lastTransLt: BN;
};
export declare function parseShardAccount(cs: Slice): RawShardAccount;
export declare type RawDepthBalanceInfo = {
    splitDepth: number;
    balance: RawCurrencyCollection;
};
export declare function parseDepthBalanceInfo(cs: Slice): RawDepthBalanceInfo;
export declare type RawShardAccountRef = {
    shardAccount: RawShardAccount;
    depthBalanceInfo: RawDepthBalanceInfo;
};
export declare function parseShardAccounts(cs: Slice): Map<string, RawShardAccountRef>;
export declare type RawMasterChainStateExtra = {
    configAddress: Address;
    config: Cell;
    globalBalance: RawCurrencyCollection;
};
export declare function parseMasterchainStateExtra(cs: Slice): RawMasterChainStateExtra;
export declare type RawShardStateUnsplit = {
    globalId: number;
    shardId: RawShardIdent;
    seqno: number;
    vertSeqNo: number;
    genUtime: number;
    genLt: BN;
    minRefSeqno: number;
    beforeSplit: boolean;
    accounts: Map<string, RawShardAccountRef>;
    extras: RawMasterChainStateExtra | null;
};
export declare function parseShardStateUnsplit(cs: Slice): RawShardStateUnsplit;
