"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const parse_1 = require("./parse");
//
// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L425
//
function computeStorageFees(data) {
    const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
    if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since.toNumber() || special) {
        return new bn_js_1.default(0);
    }
    let upto = Math.max(lastPaid, storagePrices[0].utime_since.toNumber());
    let total = new bn_js_1.default(0);
    for (let i = 0; i < storagePrices.length && upto < now; i++) {
        let valid_until = (i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since.toNumber()) : now);
        let payment = new bn_js_1.default(0);
        if (upto < valid_until) {
            let delta = valid_until - upto;
            payment = payment.add(new bn_js_1.default(storageStat.cells).mul(masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps));
            payment = payment.add(new bn_js_1.default(storageStat.bits).mul(masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps));
            payment = payment.mul(new bn_js_1.default(delta));
        }
        upto = valid_until;
        total = total.add(payment);
    }
    return shr16ceil(total);
}
exports.computeStorageFees = computeStorageFees;
//
// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L1218
//
function computeFwdFees(msgPrices, cells, bits) {
    return msgPrices.lumpPrice.add(shr16ceil(msgPrices.bitPrice.mul(bits)
        .add(msgPrices.cellPrice.mul(cells))));
}
exports.computeFwdFees = computeFwdFees;
//
// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L761
//
function computeGasPrices(gasUsed, prices) {
    if (gasUsed.lte(prices.flatLimit)) {
        return prices.flatPrice;
    }
    else {
        //  td::rshift(gas_price256 * (gas_used - cfg.flat_gas_limit), 16, 1) + cfg.flat_gas_price
        return prices.flatPrice.add(prices.price.mul(gasUsed.sub(prices.flatLimit)).shrn(16));
    }
}
exports.computeGasPrices = computeGasPrices;
//
// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L530
//
function computeExternalMessageFees(msgPrices, cell) {
    // Collect stats
    let storageStats = collectCellStats(cell);
    storageStats.bits -= cell.bits.cursor;
    storageStats.cells -= 1;
    return computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
}
exports.computeExternalMessageFees = computeExternalMessageFees;
function computeMessageForwardFees(msgPrices, cell) {
    let msg = (0, parse_1.parseMessage)(cell.beginParse());
    let storageStats = { bits: 0, cells: 0 };
    // Init
    if (msg.init) {
        let c = collectCellStats(msg.body);
        c.bits -= msg.body.bits.cursor;
        c.cells -= 1;
        storageStats.bits += c.bits;
        storageStats.cells += c.cells;
    }
    // Body
    let bc = collectCellStats(msg.body);
    bc.bits -= msg.body.bits.cursor;
    bc.cells -= 1;
    storageStats.bits += bc.bits;
    storageStats.cells += bc.cells;
    // NOTE: Extra currencies are ignored for now
    let fees = computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
    let res = fees.mul(msgPrices.firstFrac).shrn(16);
    let remaining = fees.sub(res);
    return { fees: res, remaining };
}
exports.computeMessageForwardFees = computeMessageForwardFees;
function collectCellStats(cell) {
    let bits = cell.bits.cursor;
    let cells = 1;
    for (let ref of cell.refs) {
        let r = collectCellStats(ref);
        cells += r.cells;
        bits += r.bits;
    }
    return { bits, cells };
}
function shr16ceil(src) {
    let rem = src.mod(new bn_js_1.default(65536));
    let res = src.shrn(16);
    if (!rem.eqn(0)) {
        res = res.addn(1);
    }
    return res;
}
