/// <reference types="node" />
import { AxiosAdapter } from "axios";
import BN from "bn.js";
import { Address } from "../address/Address";
import { StackItem } from "../block/stack";
import { Cell } from "../boc/Cell";
export declare type TonClient4Parameters = {
    /**
     * API endpoint
     */
    endpoint: string;
    /**
     * HTTP request timeout in milliseconds.
     */
    timeout?: number;
    /**
     * HTTP Adapter for axios
     */
    httpAdapter?: AxiosAdapter;
};
export declare class TonClient4 {
    #private;
    constructor(args: TonClient4Parameters);
    getLastBlock(): Promise<{
        last: {
            seqno: number;
            shard: string;
            workchain: number;
            fileHash: string;
            rootHash: string;
        };
        init: {
            fileHash: string;
            rootHash: string;
        };
        stateRootHash: string;
        now: number;
    }>;
    getBlock(seqno: number): Promise<{
        shards: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
            transactions: {
                account: string;
                hash: string;
                lt: string;
            }[];
        }[];
    }>;
    getBlockByUtime(ts: number): Promise<{
        shards: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
            transactions: {
                account: string;
                hash: string;
                lt: string;
            }[];
        }[];
    }>;
    getAccount(seqno: number, address: Address): Promise<{
        account: {
            state: {
                type: "uninit";
            } | {
                type: "active";
                code: string | null;
                data: string | null;
            } | {
                type: "frozen";
                stateHash: string;
            };
            balance: {
                coins: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    getAccountLite(seqno: number, address: Address): Promise<{
        account: {
            state: {
                type: "uninit";
            } | {
                type: "active";
                codeHash: string;
                dataHash: string;
            } | {
                type: "frozen";
                stateHash: string;
            };
            balance: {
                coins: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
    }>;
    isAccountChanged(seqno: number, address: Address, lt: BN): Promise<{
        changed: boolean;
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    getAccountTransactions(address: Address, lt: BN, hash: Buffer): Promise<{
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
        tx: Cell;
    }[]>;
    getConfig(seqno: number, ids?: number[]): Promise<{
        config: {
            cell: string;
            address: string;
            globalBalance: {
                coins: string;
            };
        };
    }>;
    runMethod(seqno: number, address: Address, name: string, args?: StackItem[]): Promise<{
        exitCode: number;
        result: StackItem[];
        resultRaw: string | null;
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
        shardBlock: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    sendMessage(message: Buffer): Promise<{
        status: number;
    }>;
}
