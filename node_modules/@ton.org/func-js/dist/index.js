"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileFunc = exports.compilerVersion = void 0;
const utils_1 = require("./utils");
const CompilerModule = require('./wasmlib/funcfiftlib.js');
const { FuncFiftLibWasm } = require('./wasmlib/funcfiftlib.wasm.js');
// Prepare binary
const WasmBinary = utils_1.base64Decode(FuncFiftLibWasm);
async function compilerVersion() {
    let mod = await CompilerModule({ wasmBinary: WasmBinary });
    let versionJsonPointer = mod._version();
    let versionJson = mod.UTF8ToString(versionJsonPointer);
    mod._free(versionJsonPointer);
    return JSON.parse(versionJson);
}
exports.compilerVersion = compilerVersion;
async function compileFunc(compileConfig) {
    let entryWithNoSource = compileConfig.entryPoints.find(filename => typeof compileConfig.sources[filename] !== 'string');
    if (entryWithNoSource) {
        throw new Error(`The entry point ${entryWithNoSource} has not provided in sources.`);
    }
    let mod = await CompilerModule({ wasmBinary: WasmBinary });
    // Write sources to virtual FS
    for (let fileName in compileConfig.sources) {
        let source = compileConfig.sources[fileName];
        mod.FS.writeFile(fileName, source);
    }
    let configStr = JSON.stringify({
        sources: compileConfig.entryPoints,
        optLevel: compileConfig.optLevel || 2
    });
    let configStrPointer = mod._malloc(configStr.length + 1);
    mod.stringToUTF8(configStr, configStrPointer, configStr.length + 1);
    let resultPointer = mod._func_compile(configStrPointer);
    let retJson = mod.UTF8ToString(resultPointer);
    // Cleanup
    mod._free(resultPointer);
    mod._free(configStrPointer);
    mod = null;
    return JSON.parse(retJson);
}
exports.compileFunc = compileFunc;
