"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContract = void 0;
const ton_1 = require("ton");
const executor_1 = require("../executor/executor");
const ton_compiler_1 = require("ton-compiler");
const bn_js_1 = __importDefault(require("bn.js"));
const cell_1 = require("../utils/cell");
const TvmRunner_1 = require("../executor/TvmRunner");
const parseActionList_1 = require("../utils/parseActionList");
async function normalizeTvmStackEntry(entry) {
    if (entry.type === 'null') {
        return null;
    }
    if (entry.type === 'cell') {
        return (0, cell_1.bocToCell)(entry.value);
    }
    if (entry.type === 'int') {
        return new bn_js_1.default(entry.value, 10);
    }
    if (entry.type === 'cell_slice') {
        return ton_1.Slice.fromCell((0, cell_1.bocToCell)(entry.value));
    }
    if (entry.type === 'tuple') {
        return await Promise.all(entry.value.map(v => normalizeTvmStackEntry(v)));
    }
    throw new Error('Unknown TVM stack entry' + JSON.stringify(entry));
}
async function normalizeTvmStack(stack) {
    return await Promise.all(stack.map(v => normalizeTvmStackEntry(v)));
}
const decodeLogs = (logs) => Buffer.from(logs, 'base64').toString();
//
//  Mutable Smart Contract
//
//  Invoking mutating methods of contract mutates data cell
//
class SmartContract {
    codeCell;
    dataCell;
    codeCellBoc;
    dataCellBoc;
    config;
    c7Config = {};
    c7 = null;
    constructor(codeCell, dataCell, config) {
        this.codeCell = codeCell;
        this.dataCell = dataCell;
        this.codeCellBoc = (0, cell_1.cellToBoc)(codeCell);
        this.dataCellBoc = (0, cell_1.cellToBoc)(dataCell);
        this.config = {
            getMethodsMutate: config?.getMethodsMutate ?? false,
            debug: config?.debug ?? false,
            runner: TvmRunner_1.TvmRunnerAsynchronous.getShared()
        };
    }
    async runContract(method, stack, opts) {
        let executorConfig = {
            debug: this.config.debug,
            function_selector: (0, executor_1.getSelectorForMethod)(method),
            init_stack: stack,
            code: this.codeCellBoc,
            data: this.dataCellBoc,
            c7_register: this.getC7()
        };
        let res = await this.config.runner.invoke(executorConfig);
        // In this case probably there wa something wrong with executor config
        if (!res.ok && res.error) {
            throw new Error(`Cant execute vm: ${res.error}}`);
        }
        // In this case TVM failed
        if (res.exit_code !== 0 || !res.ok) {
            let logs = res.logs ? decodeLogs(res.logs) : '';
            return {
                type: 'failed',
                exit_code: res.exit_code,
                gas_consumed: 0,
                result: [],
                action_list_cell: undefined,
                actionList: [],
                logs: logs,
            };
        }
        if (opts?.mutateData && res.data_cell) {
            this.setDataCell((0, cell_1.bocToCell)(res.data_cell));
        }
        let actionListCell = (0, cell_1.bocToCell)(res.action_list_cell);
        let actionList = (0, parseActionList_1.parseActionsList)(actionListCell);
        let setCode = actionList.find(a => a.type === 'set_code');
        if (setCode && opts?.mutateCode) {
            this.setCodeCell(setCode.newCode);
        }
        return {
            type: 'success',
            exit_code: res.exit_code,
            gas_consumed: res.gas_consumed,
            result: await normalizeTvmStack(res.stack || []),
            action_list_cell: actionListCell,
            logs: decodeLogs(res.logs),
            actionList
        };
    }
    async invokeGetMethod(method, args) {
        return await this.runContract(method, args, {
            mutateData: this.config.getMethodsMutate,
            mutateCode: this.config.getMethodsMutate
        });
    }
    async sendInternalMessage(message) {
        let msgCell = new ton_1.Cell();
        message.writeTo(msgCell);
        if (!message.body.body) {
            throw new Error('No body was provided for message');
        }
        let bodyCell = new ton_1.Cell();
        message.body.body.writeTo(bodyCell);
        let smcBalance = (this.c7Config.balance ?? new bn_js_1.default(0)).add(message.value);
        return await this.runContract('recv_internal', [
            { type: 'int', value: smcBalance.toString(10) },
            { type: 'int', value: message.value.toString(10) },
            { type: 'cell', value: await (0, cell_1.cellToBoc)(msgCell) },
            { type: 'cell_slice', value: await (0, cell_1.cellToBoc)(bodyCell) }, // body slice
        ], { mutateCode: true, mutateData: true });
    }
    async sendExternalMessage(message) {
        let msgCell = new ton_1.Cell();
        message.writeTo(msgCell);
        if (!message.body.body) {
            throw new Error('No body was provided for message');
        }
        let bodyCell = new ton_1.Cell();
        message.body.body.writeTo(bodyCell);
        let smcBalance = (this.c7Config.balance ?? new bn_js_1.default(0));
        return await this.runContract('recv_external', [
            { type: 'int', value: smcBalance.toString(10) },
            { type: 'int', value: '0' },
            { type: 'cell', value: await (0, cell_1.cellToBoc)(msgCell) },
            { type: 'cell_slice', value: await (0, cell_1.cellToBoc)(bodyCell) }, // body slice
        ], { mutateCode: true, mutateData: true });
    }
    setUnixTime(time) {
        this.c7Config.unixtime = time;
    }
    setBalance(value) {
        this.c7Config.balance = value;
    }
    setC7Config(conf) {
        this.c7Config = conf;
    }
    setC7(c7) {
        this.c7 = c7;
    }
    getC7() {
        if (this.c7) {
            return this.c7;
        }
        else {
            return (0, executor_1.buildC7)(this.c7Config);
        }
    }
    setDataCell(dataCell) {
        this.dataCell = dataCell;
        this.dataCellBoc = (0, cell_1.cellToBoc)(dataCell);
    }
    setCodeCell(codeCell) {
        this.codeCell = codeCell;
        this.codeCellBoc = (0, cell_1.cellToBoc)(codeCell);
    }
    static async fromFuncSource(source, dataCell, config) {
        let compiledSource = await (0, ton_compiler_1.compileFunc)(source);
        return new SmartContract(ton_1.Cell.fromBoc(compiledSource.cell)[0], dataCell, config);
    }
    static async fromCell(codeCell, dataCell, config) {
        return new SmartContract(codeCell, dataCell, config);
    }
}
exports.SmartContract = SmartContract;
